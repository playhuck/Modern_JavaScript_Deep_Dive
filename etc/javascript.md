# Javascript

## var / let / const 그리고 호이스팅

### 호이스팅(Hoisting)

변수 선언은 실행 컨텍스트의 동작 때문에 런타임이 아니라 그 이전 단계에서 먼저 실행되기 때문에, 변수 선언문이 코드의 선두로 끌어 올려진 것 처럼 동작하는 자바크스립트 고유의 특징을 변수 호이스팅이라고 한다.

var / let / const / function / class 등 키워드를 사용하여 선언하는 모든 식별자는 호이스팅이 이루어진다. 모든 선언문은 런타임 이전에 실행되기 때문이다.

하지만, let이나 const 같이 호이스팅이 발생하지 않는 것 처럼 보이는 식별자도 존재한다.

TDZ라고 하여 초기화되기 전까지는 **ReferenceError**를 발생시킨다.

let은 초기화 선언을 하지 않아도 사용할 수 있지만 런타임 단계에서 undefined로 초기화 되기

때문에 참조 에러를 발생 시킨다.

### var

var키워드는 중복선언과 재할당이 가능하다. 초기화하지 않아도 선언할 수 있다.

var 키워드로 선언한 변수는 오로지 함수의 코드 블록만을 지역 스코프로 인정한다.

따라서, 외부에서 var 키워드를 선언한 변수를 함수 내에서 재 선언해도 모두 전역 변수가 된다.

var 키워드로 변수를 선언하면 호이스팅에 의해 선언문이 스코프 최상단으로 끌어올려 진 것 처럼 동작한다.

### let

let은 중복선언이 불가능하고, 재할당은 가능하다. var처럼 초기화하지 않아도 선언할 수 있다.

let은 모든 코드 블록을 지역 스코프로 인정하는 블록 레벨 스코프를 따른다.

변수 호이스팅이 발생하지 않은 것 처럼 동작한다.

### const

const는 중복선언 및 재할당이 모두 불가능하다.

const는 상수를 선언하기 위해 사용된다. 

const로 선언한 변수는 반드시 선언과 동시에 초기화해야 한다.

블록레벨 스코프를 가진다.

변수 호이스팅이 발생하지 않은 것 처럼 동작한다.

const에 객체를 할당한 경우 값을 변경할 수 있다. const 키워드는 재할당을 금지할 뿐

“불변”을 의미하지는 않는다.

---

## 얕은 복사와 깊은 복사

### 얕은 복사

- 얕은 복사는 원본 객체의 최상위 레벨에서만 복사를 수행합니다.
- 내부에 객체나 배열이 있을 경우, 해당 객체나 배열은 참조로 복사되며, 원본과 복사본이 같은 내부 객체를 가리키게 됩니다.
- 얕은 복사를 통해 생성된 객체의 일부를 수정하면 해당 객체의 일부는 원본과 복사본에서 모두 변경됩니다.

일반적으로 같은 메모리 주소를 참조하고 있다면, 얕은 복사로 판단되며 값을 변경 했을 때 원본 참조 메모리 값이 변경된다면 얕은 복사다.

### 깊은 복사

- 깊은 복사는 원본 객체의 모든 단계에서 복사를 수행하여 내부 객체도 재귀적으로 복사됩니다.
- 이로 인해 원본과 복사본은 서로 독립적이며, 하나를 수정해도 다른 하나에는 영향을 주지 않습니다.
- 깊은 복사는 보다 복잡하며, 성능 측면에서 얕은 복사보다 더 많은 자원을 소비할 수 있습니다.

재귀적으로 복사한다는 소리는, 단순히 참조를 하는 것이 아닌 내부 Property 마저도 모두 복사한다는 개념으로서 값을 변경했을 때 원본 값이 변하는 것이 아닌 경우를 말한다.

이 경우 완전히 새로운 값을 생성해내는 것이기 때문에, 새로운 메모리에 할당되며 새 주소를 가지게 된다.

결론 적으로 메모리의 주소만 참조하는 수준이냐, 메모리의 모든 것을 복사해 새로운 메모리 주소를 가지느냐에 따라 얕은 복사와 깊은 복사로 나뉜다.

---

## this

this는 자기 자신이 속하거나 생성할 객체 또는 인스턴스의 자기 참조 변수이다.

this가 가리키는 값인 this 바인딩 값은 함수 호출 방식에 의해 동적으로 결정된다.

- 일반 함수 호출
    
    기본적으로 this에는 전역 객체가 바인딩 된다.
    
    일반 함수로 호출된 모든 함수(중첩 함수, 콜백 함수 포함) 내부의 this에는 전역 객체가 바인딩된다.
    

- 메서드
    
    메서드는 다른 객체에 프로퍼티에 할당하는 것으로 다른 객체의 메서드가 될 수도 있고, 일반 변수에 할당하여 일반 함수로 호출될 수도 있다.
    
    메서드 내부의 this는 프로퍼티로 메서드를 가리키고 있는 객체와는 관계가 없고, 메서드를 호출한 객체에 바인딩된다.
    

- 생성자 함수 호출
    
    생성자 함수 내부의 this에는 생성자 함수가 생성할 인스턴스가 바인딩된다.
    

**bind**메서드는 메서드의 this와 메서드 내부의 중첩 함수 또는 콜백 함수의 this가 불일치하는 문제를 해결하기 위해 유용하게 사용된다.

---

## 실행 컨텍스트

JS 엔진은 소스코드들 2개의 과정, “소스코드의 평가”와 “소스코드의 실행”과정으로 나누어 처리한다.

**소스코드의 평가 과정에서는** 실행 컨텍스트를 생성하고 변수, 함수 등의 선언문만 먼저 실행하여 생성된 변수나 함수 식별자를 키로 실행 컨텍스트가 관리하는 스코프(렉시컬 환경의 환경 레코드)에 등록한다.

**소스코드의 평가 과정이 끝나면** 비로소 선언문을 제외한 소스코드가 순차적으로 실행되기 시작한다. 즉, **런타임이 시작**된다.

이 때에 소스코드 실행에 필요한 정보, 즉 변수나 함수의 참조를 실행 컨텍스트가 관리하는 스코프에서 검색해서 취득한다. 그리고 **변수 값의 변경 등 소스코드의 실행 결과는** 다시 실행 컨텍스트가 관리하는 **스코프에 등록**된다.

**실행 컨텍스트는 식별자를 등록하고 관리하는 스코프와 코드 실행 순서 관리를 구현한 JS 내부 메커니즘으로, 모든 코드는 실행 컨텍스트를 통해 실행되고 관리된다.**

식별자와 스코프는 실행 컨텍스트의 **렉시컬 환경**으로 관리하고, 코드 실행 순서는 **실행 컨텍스트 스택**으로 관리한다.

실행 컨텍스트는 **스택 자료구조**로 관리된다.

**실행 컨텍스트 스택이 코드의 실행 순서를 관리한다면 렉시컬 환경은 스코프와 식별자를 관리한다.**

렉시컬 환경은 키와 값을 갖는 객체 형태의 스코프(전역, 함수, 블록 스코프)를 생성하여 식별자(변수, 함수, 클래스)를 키로 등록하고 식별자에 바인딩된 값을 관리한다.

---

## 클로저(Closer)

클로저는 함수와 그 함수가 선언된 렉시컬 환경과의 조합이다.

JS 엔진은 함수를 어디서 호출 했는지가 아닌, 어디서 정의 했는지에 따라 

상위 스코프가 결정된다. 이를 렉시컬 스코프라고 한다.

**중첩 함수는 이미 생명주기가 종료된 외부 함수의 변수를 참조할 수 있기 때문이다.** 

**이런 중첩 함수를 `클로저`라고 한다.**

클로저 내부 슬롯에 저장된 상위 스코프의 참조 값을 불러내어 동작한다.

**클로저는 중첩 함수가 상위 스코프의 식별자를 참조하고 있고 중첩 함수가** 

**외부 함수보다 더 오래 유지되는 경우에 한정하는 것이 일반적이다.**

**클로저는 상태(state)를 안전하게 변경하고 유지하기 위해 사용된다.**

함수 블록 안의 중첩 함수에서 클로저를 생성한다면 어디선가 이 값을 불러 왔을 때 상태를

공유하지 않지만, 특정 함수 자체가 클로저를 만들어 내고 있다면 상태를 공유하여

사용할 수 있다.

---

## Promise